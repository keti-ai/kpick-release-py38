from .utils import *
import torch
from _typeshed import Incomplete
from pathlib import Path as Path
from torchvision import models as models, utils as utils

class ImageDataset(torch.utils.data.Dataset):
    transform: Incomplete
    template_path: Incomplete
    image_name: Incomplete
    image_raw: Incomplete
    thresh_df: Incomplete
    image: Incomplete
    def __init__(self, template_dir_path, image_name, thresh_csv: Incomplete | None = ..., transform: Incomplete | None = ...) -> None: ...
    def __len__(self): ...
    def __getitem__(self, idx): ...

class Featex:
    use_cuda: Incomplete
    feature1: Incomplete
    feature2: Incomplete
    model: Incomplete
    def __init__(self, model, use_cuda) -> None: ...
    def save_feature1(self, module, input, output) -> None: ...
    def save_feature2(self, module, input, output) -> None: ...
    def __call__(self, input, mode: str = ...): ...

class MyNormLayer:
    def __call__(self, x1, x2): ...

class CreateModel:
    alpha: Incomplete
    featex: Incomplete
    I_feat: Incomplete
    def __init__(self, alpha, model, use_cuda) -> None: ...
    def __call__(self, template, image, image_name): ...

class QATM:
    alpha: Incomplete
    def __init__(self, alpha) -> None: ...
    def __call__(self, x): ...
    def compute_output_shape(self, input_shape): ...

def nms(score, w_ini, h_ini, thresh: float = ...): ...
def plot_result(image_raw, boxes, show: bool = ..., save_name: Incomplete | None = ..., color=...): ...
def nms_multi(scores, w_array, h_array, thresh_list): ...
def plot_result_multi(image_raw, boxes, indices, show: bool = ..., save_name: Incomplete | None = ..., color_list: Incomplete | None = ...): ...
def run_one_sample(model, template, image, image_name: str = ...): ...
def run_multi_sample(model, dataset): ...
